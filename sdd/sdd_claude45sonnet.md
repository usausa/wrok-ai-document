# AI駆動開発と仕様駆動開発(SDD)の関係性

## 1. 両者の基本的な関係

AI駆動開発と仕様駆動開発は、**相互補完的な関係**にあります。

### 従来のSDD
```
仕様書作成 → 設計 → 実装 → テスト
```

### AI駆動開発におけるSDD
```
仕様定義 → AIへの指示(プロンプト) → コード生成 → 検証・改善
```

## 2. AIがSDDを強化する3つのポイント

### ✅ (1) 仕様の重要性が増大
```markdown
【悪い例】
「ログイン機能を作って」

【良い例】
- ユーザー名とパスワードでの認証
- 3回失敗でアカウントロック（15分間）
- セッション有効期限：24時間
- パスワードは bcrypt でハッシュ化
- エラーメッセージは攻撃者に情報を与えない
```

**AIは曖昧な指示では曖昧な結果を返します**

### ✅ (2) 仕様の反復的改善が容易に

```python
# 第1イテレーション：基本仕様
「ユーザー登録APIを作成」

# 第2イテレーション：仕様を具体化
「バリデーション追加：メールアドレス形式チェック」

# 第3イテレーション：セキュリティ仕様追加
「レート制限を追加：同一IPから1分間に5回まで」
```

### ✅ (3) 仕様とコードの同期が保たれやすい

従来は仕様書とコードが乖離しがちでしたが、AIを使うと：
- 仕様を更新 → AIに再生成依頼 → 最新コードを取得

## 3. 実践的なワークフロー

### ステップ1：仕様の明確化
```yaml
機能: ユーザー検索API
エンドポイント: GET /api/users/search
パラメータ:
  - q: 検索キーワード（必須、2文字以上）
  - page: ページ番号（任意、デフォルト1）
  - limit: 件数（任意、デフォルト20、最大100）
レスポンス:
  - 200: ユーザーリスト（JSON）
  - 400: バリデーションエラー
  - 429: レート制限超過
```

### ステップ2：AIへの構造化された指示
```
上記仕様に基づいて、以下を生成してください：
1. Express.jsのルートハンドラー
2. 入力バリデーション
3. エラーハンドリング
4. OpenAPI仕様書
```

### ステップ3：生成結果の検証
- 仕様との整合性チェック
- セキュリティ要件の確認
- エッジケースの考慮

## 4. 開発者が注意すべきポイント

### ⚠️ AIは仕様を「推測」する
```javascript
// 「ソート機能を追加」だけでは不十分
// AIが勝手に昇順を選ぶかもしれない

// 明確に指定すべき：
// - ソート対象フィールド
// - デフォルトのソート順
// - 複数フィールドでのソート可否
```

### ⚠️ 非機能要件も明示する
```
機能要件：データを保存する
非機能要件：
- パフォーマンス：1000件/秒の書き込み
- 可用性：99.9%のアップタイム
- セキュリティ：GDPR準拠
```

### ⚠️ AIの出力は「提案」であり「正解」ではない

## 5. 推奨する開発プロセス

```
仕様定義 → AIに指示 → コード生成 
    ↑                        ↓
    ←← レビュー・改善 ←← 検証
```

1. **仕様ファースト**：実装前に仕様を文書化
2. **段階的詳細化**：大枠→詳細へ段階的に
3. **継続的検証**：生成コードが仕様を満たすか確認
4. **仕様の進化**：学んだことを仕様にフィードバック

## 6. まとめ

| 観点 | 従来のSDD | AI駆動開発でのSDD |
|------|-----------|-------------------|
| 仕様の役割 | 設計の基礎 | **AIへの指示書** |
| 詳細度 | 実装者に委ねる部分も | **より明確に** |
| 更新頻度 | 低い | **高い（反復的）** |
| コードとの関係 | 乖離しやすい | **同期しやすい** |

**結論**：AI時代において、仕様駆動開発はむしろ**より重要**になります。明確な仕様がAIの能力を最大限引き出す鍵となります。
